import { DappMetadata, Explorer, OnConnect, OnDisconnectCallback, OnInitCallback, Providers, State } from './_types';
import { Logger } from 'tslog';
export type RadixDappToolkitConfiguration = {
    initialState?: State;
    logger?: Logger<unknown>;
    networkId?: number;
    onInit?: OnInitCallback;
    onDisconnect?: OnDisconnectCallback;
    onReset?: OnConnect;
    providers?: Partial<Providers>;
    useDoneCallback?: boolean;
    explorer?: Explorer;
    gatewayBaseUrl?: string;
    onStateChange?: (state: State) => void;
    useCache?: boolean;
};
export declare const RadixDappToolkit: ({ dAppDefinitionAddress, dAppName }: DappMetadata, onConnect?: OnConnect, configuration?: RadixDappToolkitConfiguration) => {
    requestData: (value: {
        accounts?: ({
            quantifier: "exactly" | "atLeast";
            quantity: number;
        } & {
            oneTime?: boolean | undefined;
            reset?: boolean | undefined;
        }) | undefined;
        personaData?: ({
            fields: ("emailAddress" | "familyName" | "givenName" | "phoneNumber")[];
        } & {
            oneTime?: boolean | undefined;
            reset?: boolean | undefined;
        }) | undefined;
    }) => import("neverthrow").ResultAsync<{
        accounts: {
            address: string;
            label: string;
            appearanceId: number;
        }[];
        personaData: {
            value: string;
            field: "emailAddress" | "familyName" | "givenName" | "phoneNumber";
        }[];
        persona: {
            label: string;
            identityAddress: string;
        } | undefined;
    }, import("@radixdlt/wallet-sdk").SdkError>;
    sendTransaction: (input: {
        transactionManifest: string;
        version: number;
        blobs?: string[] | undefined;
        message?: string | undefined;
    }) => import("neverthrow").ResultAsync<{
        transactionIntentHash: string;
        status: import("@radixdlt/babylon-gateway-api-sdk").TransactionStatus;
    }, import("@radixdlt/wallet-sdk").SdkError>;
    state$: import("rxjs").ReplaySubject<State>;
    updateSharedData: () => void;
    disconnect: () => void;
    destroy: () => void;
};
