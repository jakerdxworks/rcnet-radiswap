var Yn = Object.defineProperty;
var Kn = (t, e, n) => e in t ? Yn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var _e = (t, e, n) => (Kn(t, typeof e != "symbol" ? e + "" : e, n), n);
var ct = function(t, e) {
  return ct = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s]);
  }, ct(t, e);
};
function oe(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  ct(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
function Jn(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (_) {
        o(_);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (_) {
        o(_);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function on(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ae(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function me(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function ye(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
function Te(t) {
  return this instanceof Te ? (this.v = t, this) : new Te(t);
}
function Qn(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(m) {
    r[m] && (s[m] = function(w) {
      return new Promise(function($, p) {
        i.push([m, w, $, p]) > 1 || a(m, w);
      });
    });
  }
  function a(m, w) {
    try {
      c(r[m](w));
    } catch ($) {
      _(i[0][3], $);
    }
  }
  function c(m) {
    m.value instanceof Te ? Promise.resolve(m.value.v).then(u, l) : _(i[0][2], m);
  }
  function u(m) {
    a("next", m);
  }
  function l(m) {
    a("throw", m);
  }
  function _(m, w) {
    m(w), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Xn(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ae == "function" ? Ae(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(i) {
    n[i] = t[i] && function(o) {
      return new Promise(function(a, c) {
        o = t[i](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function C(t) {
  return typeof t == "function";
}
function Pt(t) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = t(e);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var rt = Pt(function(t) {
  return function(n) {
    t(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, s) {
      return s + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function Ve(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var Re = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, n, r, s, i;
    if (!this.closed) {
      this.closed = !0;
      var o = this._parentage;
      if (o)
        if (this._parentage = null, Array.isArray(o))
          try {
            for (var a = Ae(o), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (p) {
            e = { error: p };
          } finally {
            try {
              c && !c.done && (n = a.return) && n.call(a);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          o.remove(this);
      var l = this.initialTeardown;
      if (C(l))
        try {
          l();
        } catch (p) {
          i = p instanceof rt ? p.errors : [p];
        }
      var _ = this._finalizers;
      if (_) {
        this._finalizers = null;
        try {
          for (var m = Ae(_), w = m.next(); !w.done; w = m.next()) {
            var $ = w.value;
            try {
              Ut($);
            } catch (p) {
              i = i ?? [], p instanceof rt ? i = ye(ye([], me(i)), me(p.errors)) : i.push(p);
            }
          }
        } catch (p) {
          r = { error: p };
        } finally {
          try {
            w && !w.done && (s = m.return) && s.call(m);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (i)
        throw new rt(i);
    }
  }, t.prototype.add = function(e) {
    var n;
    if (e && e !== this)
      if (this.closed)
        Ut(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var n = this._parentage;
    return n === e || Array.isArray(n) && n.includes(e);
  }, t.prototype._addParent = function(e) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
  }, t.prototype._removeParent = function(e) {
    var n = this._parentage;
    n === e ? this._parentage = null : Array.isArray(n) && Ve(n, e);
  }, t.prototype.remove = function(e) {
    var n = this._finalizers;
    n && Ve(n, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), an = Re.EMPTY;
function un(t) {
  return t instanceof Re || t && "closed" in t && C(t.remove) && C(t.add) && C(t.unsubscribe);
}
function Ut(t) {
  C(t) ? t() : t.unsubscribe();
}
var Rt = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, lt = {
  setTimeout: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = lt.delegate;
    return s != null && s.setTimeout ? s.setTimeout.apply(s, ye([t, e], me(n))) : setTimeout.apply(void 0, ye([t, e], me(n)));
  },
  clearTimeout: function(t) {
    var e = lt.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(t);
  },
  delegate: void 0
};
function cn(t) {
  lt.setTimeout(function() {
    throw t;
  });
}
function dt() {
}
var Ue = null;
function Be(t) {
  if (Rt.useDeprecatedSynchronousErrorHandling) {
    var e = !Ue;
    if (e && (Ue = { errorThrown: !1, error: null }), t(), e) {
      var n = Ue, r = n.errorThrown, s = n.error;
      if (Ue = null, r)
        throw s;
    }
  } else
    t();
}
var Nt = function(t) {
  oe(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, un(n) && n.add(r)) : r.destination = rr, r;
  }
  return e.create = function(n, r, s) {
    return new Ee(n, r, s);
  }, e.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, e.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(n) {
    this.destination.next(n);
  }, e.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Re), er = Function.prototype.bind;
function st(t, e) {
  return er.call(t, e);
}
var tr = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(e);
      } catch (r) {
        We(r);
      }
  }, t.prototype.error = function(e) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(e);
      } catch (r) {
        We(r);
      }
    else
      We(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (n) {
        We(n);
      }
  }, t;
}(), Ee = function(t) {
  oe(e, t);
  function e(n, r, s) {
    var i = t.call(this) || this, o;
    if (C(n) || !n)
      o = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: s ?? void 0
      };
    else {
      var a;
      i && Rt.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return i.unsubscribe();
      }, o = {
        next: n.next && st(n.next, a),
        error: n.error && st(n.error, a),
        complete: n.complete && st(n.complete, a)
      }) : o = n;
    }
    return i.destination = new tr(o), i;
  }
  return e;
}(Nt);
function We(t) {
  cn(t);
}
function nr(t) {
  throw t;
}
var rr = {
  closed: !0,
  next: dt,
  error: nr,
  complete: dt
}, Ct = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function et(t) {
  return t;
}
function sr(t) {
  return t.length === 0 ? et : t.length === 1 ? t[0] : function(n) {
    return t.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}
var U = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var n = new t();
    return n.source = this, n.operator = e, n;
  }, t.prototype.subscribe = function(e, n, r) {
    var s = this, i = or(e) ? e : new Ee(e, n, r);
    return Be(function() {
      var o = s, a = o.operator, c = o.source;
      i.add(a ? a.call(i, c) : c ? s._subscribe(i) : s._trySubscribe(i));
    }), i;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (n) {
      e.error(n);
    }
  }, t.prototype.forEach = function(e, n) {
    var r = this;
    return n = Wt(n), new n(function(s, i) {
      var o = new Ee({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            i(c), o.unsubscribe();
          }
        },
        error: i,
        complete: s
      });
      r.subscribe(o);
    });
  }, t.prototype._subscribe = function(e) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
  }, t.prototype[Ct] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], n = 0; n < arguments.length; n++)
      e[n] = arguments[n];
    return sr(e)(this);
  }, t.prototype.toPromise = function(e) {
    var n = this;
    return e = Wt(e), new e(function(r, s) {
      var i;
      n.subscribe(function(o) {
        return i = o;
      }, function(o) {
        return s(o);
      }, function() {
        return r(i);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function Wt(t) {
  var e;
  return (e = t ?? Rt.Promise) !== null && e !== void 0 ? e : Promise;
}
function ir(t) {
  return t && C(t.next) && C(t.error) && C(t.complete);
}
function or(t) {
  return t && t instanceof Nt || ir(t) && un(t);
}
function ar(t) {
  return C(t == null ? void 0 : t.lift);
}
function F(t) {
  return function(e) {
    if (ar(e))
      return e.lift(function(n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function H(t, e, n, r, s) {
  return new ur(t, e, n, r, s);
}
var ur = function(t) {
  oe(e, t);
  function e(n, r, s, i, o, a) {
    var c = t.call(this, n) || this;
    return c.onFinalize = o, c.shouldUnsubscribe = a, c._next = r ? function(u) {
      try {
        r(u);
      } catch (l) {
        n.error(l);
      }
    } : t.prototype._next, c._error = i ? function(u) {
      try {
        i(u);
      } catch (l) {
        n.error(l);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, c._complete = s ? function() {
      try {
        s();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, e;
}(Nt), cr = Pt(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), te = function(t) {
  oe(e, t);
  function e() {
    var n = t.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return e.prototype.lift = function(n) {
    var r = new qt(this, this);
    return r.operator = n, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new cr();
  }, e.prototype.next = function(n) {
    var r = this;
    Be(function() {
      var s, i;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var o = Ae(r.currentObservers), a = o.next(); !a.done; a = o.next()) {
            var c = a.value;
            c.next(n);
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            a && !a.done && (i = o.return) && i.call(o);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
    });
  }, e.prototype.error = function(n) {
    var r = this;
    Be(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var s = r.observers; s.length; )
          s.shift().error(n);
      }
    });
  }, e.prototype.complete = function() {
    var n = this;
    Be(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
  }, e.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, e.prototype._innerSubscribe = function(n) {
    var r = this, s = this, i = s.hasError, o = s.isStopped, a = s.observers;
    return i || o ? an : (this.currentObservers = null, a.push(n), new Re(function() {
      r.currentObservers = null, Ve(a, n);
    }));
  }, e.prototype._checkFinalizedStatuses = function(n) {
    var r = this, s = r.hasError, i = r.thrownError, o = r.isStopped;
    s ? n.error(i) : o && n.complete();
  }, e.prototype.asObservable = function() {
    var n = new U();
    return n.source = this, n;
  }, e.create = function(n, r) {
    return new qt(n, r);
  }, e;
}(U), qt = function(t) {
  oe(e, t);
  function e(n, r) {
    var s = t.call(this) || this;
    return s.destination = n, s.source = r, s;
  }
  return e.prototype.next = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, n);
  }, e.prototype.error = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, n);
  }, e.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, e.prototype._subscribe = function(n) {
    var r, s;
    return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && s !== void 0 ? s : an;
  }, e;
}(te), ln = {
  now: function() {
    return (ln.delegate || Date).now();
  },
  delegate: void 0
}, lr = function(t) {
  oe(e, t);
  function e(n, r) {
    return t.call(this) || this;
  }
  return e.prototype.schedule = function(n, r) {
    return this;
  }, e;
}(Re), ze = {
  setInterval: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = ze.delegate;
    return s != null && s.setInterval ? s.setInterval.apply(s, ye([t, e], me(n))) : setInterval.apply(void 0, ye([t, e], me(n)));
  },
  clearInterval: function(t) {
    var e = ze.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(t);
  },
  delegate: void 0
}, dr = function(t) {
  oe(e, t);
  function e(n, r) {
    var s = t.call(this, n, r) || this;
    return s.scheduler = n, s.work = r, s.pending = !1, s;
  }
  return e.prototype.schedule = function(n, r) {
    var s;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var i = this.id, o = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(o, i, r)), this.pending = !0, this.delay = r, this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(o, this.id, r), this;
  }, e.prototype.requestAsyncId = function(n, r, s) {
    return s === void 0 && (s = 0), ze.setInterval(n.flush.bind(n, this), s);
  }, e.prototype.recycleAsyncId = function(n, r, s) {
    if (s === void 0 && (s = 0), s != null && this.delay === s && this.pending === !1)
      return r;
    r != null && ze.clearInterval(r);
  }, e.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var s = this._execute(n, r);
    if (s)
      return s;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(n, r) {
    var s = !1, i;
    try {
      this.work(n);
    } catch (o) {
      s = !0, i = o || new Error("Scheduled action threw falsy error");
    }
    if (s)
      return this.unsubscribe(), i;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, s = n.scheduler, i = s.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, Ve(i, this), r != null && (this.id = this.recycleAsyncId(s, r, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, e;
}(lr), Ft = function() {
  function t(e, n) {
    n === void 0 && (n = t.now), this.schedulerActionCtor = e, this.now = n;
  }
  return t.prototype.schedule = function(e, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, e).schedule(r, n);
  }, t.now = ln.now, t;
}(), fr = function(t) {
  oe(e, t);
  function e(n, r) {
    r === void 0 && (r = Ft.now);
    var s = t.call(this, n, r) || this;
    return s.actions = [], s._active = !1, s;
  }
  return e.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var s;
    this._active = !0;
    do
      if (s = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, s) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw s;
    }
  }, e;
}(Ft), hr = new fr(dr), pr = hr, dn = new U(function(t) {
  return t.complete();
});
function fn(t) {
  return t && C(t.schedule);
}
function hn(t) {
  return t[t.length - 1];
}
function pn(t) {
  return fn(hn(t)) ? t.pop() : void 0;
}
function mr(t, e) {
  return typeof hn(t) == "number" ? t.pop() : e;
}
var mn = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function yn(t) {
  return C(t == null ? void 0 : t.then);
}
function vn(t) {
  return C(t[Ct]);
}
function gn(t) {
  return Symbol.asyncIterator && C(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function _n(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function yr() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var bn = yr();
function wn(t) {
  return C(t == null ? void 0 : t[bn]);
}
function xn(t) {
  return Qn(this, arguments, function() {
    var n, r, s, i;
    return on(this, function(o) {
      switch (o.label) {
        case 0:
          n = t.getReader(), o.label = 1;
        case 1:
          o.trys.push([1, , 9, 10]), o.label = 2;
        case 2:
          return [4, Te(n.read())];
        case 3:
          return r = o.sent(), s = r.value, i = r.done, i ? [4, Te(void 0)] : [3, 5];
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, Te(s)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function Tn(t) {
  return C(t == null ? void 0 : t.getReader);
}
function ae(t) {
  if (t instanceof U)
    return t;
  if (t != null) {
    if (vn(t))
      return vr(t);
    if (mn(t))
      return gr(t);
    if (yn(t))
      return _r(t);
    if (gn(t))
      return Sn(t);
    if (wn(t))
      return br(t);
    if (Tn(t))
      return wr(t);
  }
  throw _n(t);
}
function vr(t) {
  return new U(function(e) {
    var n = t[Ct]();
    if (C(n.subscribe))
      return n.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function gr(t) {
  return new U(function(e) {
    for (var n = 0; n < t.length && !e.closed; n++)
      e.next(t[n]);
    e.complete();
  });
}
function _r(t) {
  return new U(function(e) {
    t.then(function(n) {
      e.closed || (e.next(n), e.complete());
    }, function(n) {
      return e.error(n);
    }).then(null, cn);
  });
}
function br(t) {
  return new U(function(e) {
    var n, r;
    try {
      for (var s = Ae(t), i = s.next(); !i.done; i = s.next()) {
        var o = i.value;
        if (e.next(o), e.closed)
          return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        i && !i.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    e.complete();
  });
}
function Sn(t) {
  return new U(function(e) {
    xr(t, e).catch(function(n) {
      return e.error(n);
    });
  });
}
function wr(t) {
  return Sn(xn(t));
}
function xr(t, e) {
  var n, r, s, i;
  return Jn(this, void 0, void 0, function() {
    var o, a;
    return on(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = Xn(t), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (o = r.value, e.next(o), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), s = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (i = n.return) ? [4, i.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (s)
            throw s.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ne(t, e, n, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = !1);
  var i = e.schedule(function() {
    n(), s ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(i), !s)
    return i;
}
function On(t, e) {
  return e === void 0 && (e = 0), F(function(n, r) {
    n.subscribe(H(r, function(s) {
      return ne(r, t, function() {
        return r.next(s);
      }, e);
    }, function() {
      return ne(r, t, function() {
        return r.complete();
      }, e);
    }, function(s) {
      return ne(r, t, function() {
        return r.error(s);
      }, e);
    }));
  });
}
function An(t, e) {
  return e === void 0 && (e = 0), F(function(n, r) {
    r.add(t.schedule(function() {
      return n.subscribe(r);
    }, e));
  });
}
function Tr(t, e) {
  return ae(t).pipe(An(e), On(e));
}
function Sr(t, e) {
  return ae(t).pipe(An(e), On(e));
}
function Or(t, e) {
  return new U(function(n) {
    var r = 0;
    return e.schedule(function() {
      r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function Ar(t, e) {
  return new U(function(n) {
    var r;
    return ne(n, e, function() {
      r = t[bn](), ne(n, e, function() {
        var s, i, o;
        try {
          s = r.next(), i = s.value, o = s.done;
        } catch (a) {
          n.error(a);
          return;
        }
        o ? n.complete() : n.next(i);
      }, 0, !0);
    }), function() {
      return C(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function En(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new U(function(n) {
    ne(n, e, function() {
      var r = t[Symbol.asyncIterator]();
      ne(n, e, function() {
        r.next().then(function(s) {
          s.done ? n.complete() : n.next(s.value);
        });
      }, 0, !0);
    });
  });
}
function Er(t, e) {
  return En(xn(t), e);
}
function kr(t, e) {
  if (t != null) {
    if (vn(t))
      return Tr(t, e);
    if (mn(t))
      return Or(t, e);
    if (yn(t))
      return Sr(t, e);
    if (gn(t))
      return En(t, e);
    if (wn(t))
      return Ar(t, e);
    if (Tn(t))
      return Er(t, e);
  }
  throw _n(t);
}
function kn(t, e) {
  return e ? kr(t, e) : ae(t);
}
function Ir() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = pn(t);
  return kn(t, n);
}
var $t = Pt(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Pr(t, e) {
  var n = typeof e == "object";
  return new Promise(function(r, s) {
    var i = new Ee({
      next: function(o) {
        r(o), i.unsubscribe();
      },
      error: s,
      complete: function() {
        n ? r(e.defaultValue) : s(new $t());
      }
    });
    t.subscribe(i);
  });
}
function Rr(t) {
  return t instanceof Date && !isNaN(t);
}
function $e(t, e) {
  return F(function(n, r) {
    var s = 0;
    n.subscribe(H(r, function(i) {
      r.next(t.call(e, i, s++));
    }));
  });
}
function Nr(t, e, n, r, s, i, o, a) {
  var c = [], u = 0, l = 0, _ = !1, m = function() {
    _ && !c.length && !u && e.complete();
  }, w = function(p) {
    return u < r ? $(p) : c.push(p);
  }, $ = function(p) {
    i && e.next(p), u++;
    var k = !1;
    ae(n(p, l++)).subscribe(H(e, function(I) {
      s == null || s(I), i ? w(I) : e.next(I);
    }, function() {
      k = !0;
    }, void 0, function() {
      if (k)
        try {
          u--;
          for (var I = function() {
            var x = c.shift();
            o ? ne(e, o, function() {
              return $(x);
            }) : $(x);
          }; c.length && u < r; )
            I();
          m();
        } catch (x) {
          e.error(x);
        }
    }));
  };
  return t.subscribe(H(e, w, function() {
    _ = !0, m();
  })), function() {
    a == null || a();
  };
}
function In(t, e, n) {
  return n === void 0 && (n = 1 / 0), C(e) ? In(function(r, s) {
    return $e(function(i, o) {
      return e(r, i, s, o);
    })(ae(t(r, s)));
  }, n) : (typeof e == "number" && (n = e), F(function(r, s) {
    return Nr(r, s, t, n);
  }));
}
function Cr(t) {
  return t === void 0 && (t = 1 / 0), In(et, t);
}
function $r(t, e, n) {
  t === void 0 && (t = 0), n === void 0 && (n = pr);
  var r = -1;
  return e != null && (fn(e) ? n = e : r = e), new U(function(s) {
    var i = Rr(t) ? +t - n.now() : t;
    i < 0 && (i = 0);
    var o = 0;
    return n.schedule(function() {
      s.closed || (s.next(o++), 0 <= r ? this.schedule(void 0, r) : s.complete());
    }, i);
  });
}
function it() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = pn(t), r = mr(t, 1 / 0), s = t;
  return s.length ? s.length === 1 ? ae(s[0]) : Cr(r)(kn(s, n)) : dn;
}
function je(t, e) {
  return F(function(n, r) {
    var s = 0;
    n.subscribe(H(r, function(i) {
      return t.call(e, i, s++) && r.next(i);
    }));
  });
}
function jr(t) {
  return F(function(e, n) {
    var r = !1;
    e.subscribe(H(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      r || n.next(t), n.complete();
    }));
  });
}
function Lr(t) {
  return t <= 0 ? function() {
    return dn;
  } : F(function(e, n) {
    var r = 0;
    e.subscribe(H(n, function(s) {
      ++r <= t && (n.next(s), t <= r && n.complete());
    }));
  });
}
function Mr(t) {
  return t === void 0 && (t = Dr), F(function(e, n) {
    var r = !1;
    e.subscribe(H(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      return r ? n.complete() : n.error(t());
    }));
  });
}
function Dr() {
  return new $t();
}
function Bt(t, e) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(t ? je(function(s, i) {
      return t(s, i, r);
    }) : et, Lr(1), n ? jr(e) : Mr(function() {
      return new $t();
    }));
  };
}
function Pn(t) {
  t === void 0 && (t = {});
  var e = t.connector, n = e === void 0 ? function() {
    return new te();
  } : e, r = t.resetOnError, s = r === void 0 ? !0 : r, i = t.resetOnComplete, o = i === void 0 ? !0 : i, a = t.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, _, m, w = 0, $ = !1, p = !1, k = function() {
      _ == null || _.unsubscribe(), _ = void 0;
    }, I = function() {
      k(), l = m = void 0, $ = p = !1;
    }, x = function() {
      var ee = l;
      I(), ee == null || ee.unsubscribe();
    };
    return F(function(ee, j) {
      w++, !p && !$ && k();
      var ge = m = m ?? n();
      j.add(function() {
        w--, w === 0 && !p && !$ && (_ = ot(x, c));
      }), ge.subscribe(j), !l && w > 0 && (l = new Ee({
        next: function(ue) {
          return ge.next(ue);
        },
        error: function(ue) {
          p = !0, k(), _ = ot(I, s, ue), ge.error(ue);
        },
        complete: function() {
          $ = !0, k(), _ = ot(I, o), ge.complete();
        }
      }), ae(ee).subscribe(l));
    })(u);
  };
}
function ot(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var s = new Ee({
      next: function() {
        s.unsubscribe(), t();
      }
    });
    return e.apply(void 0, ye([], me(n))).subscribe(s);
  }
}
function Zr(t) {
  return F(function(e, n) {
    ae(t).subscribe(H(n, function() {
      return n.complete();
    }, dt)), !n.closed && e.subscribe(n);
  });
}
function Se(t, e, n) {
  var r = C(t) || e || n ? { next: t, error: e, complete: n } : t;
  return r ? F(function(s, i) {
    var o;
    (o = r.subscribe) === null || o === void 0 || o.call(r);
    var a = !0;
    s.subscribe(H(i, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), i.next(c);
    }, function() {
      var c;
      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), i.complete();
    }, function(c) {
      var u;
      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), i.error(c);
    }, function() {
      var c, u;
      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : et;
}
const Ur = () => ({
  outgoingMessageSubject: new te(),
  incomingMessageSubject: new te(),
  responseSubject: new te(),
  messageLifeCycleEventSubject: new te(),
  dispatchEventSubject: new te()
}), ft = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, Wr = (t) => t.outgoingMessageSubject.pipe(
  $e((e) => ({
    event: ft.outgoingMessage,
    payload: e
  })),
  Se((e) => {
    t.dispatchEventSubject.next(e);
  }),
  Pn()
);
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Rn = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.log = n();
  })(Ce, function() {
    var e = function() {
    }, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), s = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function i(p, k) {
      var I = p[k];
      if (typeof I.bind == "function")
        return I.bind(p);
      try {
        return Function.prototype.bind.call(I, p);
      } catch {
        return function() {
          return Function.prototype.apply.apply(I, [p, arguments]);
        };
      }
    }
    function o() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function a(p) {
      return p === "debug" && (p = "log"), typeof console === n ? !1 : p === "trace" && r ? o : console[p] !== void 0 ? i(console, p) : console.log !== void 0 ? i(console, "log") : e;
    }
    function c(p, k) {
      for (var I = 0; I < s.length; I++) {
        var x = s[I];
        this[x] = I < p ? e : this.methodFactory(x, p, k);
      }
      this.log = this.debug;
    }
    function u(p, k, I) {
      return function() {
        typeof console !== n && (c.call(this, k, I), this[p].apply(this, arguments));
      };
    }
    function l(p, k, I) {
      return a(p) || u.apply(this, arguments);
    }
    function _(p, k, I) {
      var x = this, ee;
      k = k ?? "WARN";
      var j = "loglevel";
      typeof p == "string" ? j += ":" + p : typeof p == "symbol" && (j = void 0);
      function ge(A) {
        var ce = (s[A] || "silent").toUpperCase();
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage[j] = ce;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=" + ce + ";";
          } catch {
          }
        }
      }
      function ue() {
        var A;
        if (!(typeof window === n || !j)) {
          try {
            A = window.localStorage[j];
          } catch {
          }
          if (typeof A === n)
            try {
              var ce = window.document.cookie, Ze = ce.indexOf(
                encodeURIComponent(j) + "="
              );
              Ze !== -1 && (A = /^([^;]+)/.exec(ce.slice(Ze))[1]);
            } catch {
            }
          return x.levels[A] === void 0 && (A = void 0), A;
        }
      }
      function Hn() {
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage.removeItem(j);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      x.name = p, x.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, x.methodFactory = I || l, x.getLevel = function() {
        return ee;
      }, x.setLevel = function(A, ce) {
        if (typeof A == "string" && x.levels[A.toUpperCase()] !== void 0 && (A = x.levels[A.toUpperCase()]), typeof A == "number" && A >= 0 && A <= x.levels.SILENT) {
          if (ee = A, ce !== !1 && ge(A), c.call(x, A, p), typeof console === n && A < x.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + A;
      }, x.setDefaultLevel = function(A) {
        k = A, ue() || x.setLevel(A, !1);
      }, x.resetLevel = function() {
        x.setLevel(k, !1), Hn();
      }, x.enableAll = function(A) {
        x.setLevel(x.levels.TRACE, A);
      }, x.disableAll = function(A) {
        x.setLevel(x.levels.SILENT, A);
      };
      var nt = ue();
      nt == null && (nt = k), x.setLevel(nt, !1);
    }
    var m = new _(), w = {};
    m.getLogger = function(k) {
      if (typeof k != "symbol" && typeof k != "string" || k === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var I = w[k];
      return I || (I = w[k] = new _(
        k,
        m.getLevel(),
        m.methodFactory
      )), I;
    };
    var $ = typeof window !== n ? window.log : void 0;
    return m.noConflict = function() {
      return typeof window !== n && window.log === m && (window.log = $), m;
    }, m.getLoggers = function() {
      return w;
    }, m.default = m, m;
  });
})(Rn);
const q = Rn.exports, qr = (t) => t.incomingMessageSubject.pipe(
  Se((e) => {
    "eventType" in e ? (q.debug(
      `🔵💬⬇️ message lifecycle event
${JSON.stringify(e, null, 2)}`
    ), t.messageLifeCycleEventSubject.next(e)) : (q.debug(`🔵⬇️ wallet response
${JSON.stringify(e, null, 2)}`), t.responseSubject.next(e));
  })
), Fr = (t) => t.dispatchEventSubject.pipe(
  Se(({ event: e, payload: n }) => {
    q.debug(`🔵⬆️ wallet request
${JSON.stringify(n, null, 2)}`), window.dispatchEvent(
      new CustomEvent(e, {
        detail: n
      })
    );
  })
), Br = (t) => {
  const e = new Re();
  return e.add(Fr(t).subscribe()), e.add(Wr(t).subscribe()), e.add(qr(t).subscribe()), e;
}, Vr = (t) => {
  const e = (r) => {
    const s = r.detail;
    t.incomingMessageSubject.next(s);
  };
  return addEventListener(ft.incomingMessage, e), { destroy: () => {
    removeEventListener(ft.incomingMessage, e);
  } };
}, zr = (t = Ur()) => {
  const e = Br(t), n = Vr(t);
  return { destroy: () => {
    n.destroy(), e.unsubscribe();
  }, subjects: t };
};
function at(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (_) {
        o(_);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (_) {
        o(_);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function ut(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function He(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function he(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var Hr = {
  withStackTrace: !1
}, Nn = function(t, e, n) {
  n === void 0 && (n = Hr);
  var r = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, s = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: t,
    stack: s
  };
}, X = function() {
  function t(e) {
    this._promise = e;
  }
  return t.fromSafePromise = function(e) {
    var n = e.then(function(r) {
      return new le(r);
    });
    return new t(n);
  }, t.fromPromise = function(e, n) {
    var r = e.then(function(s) {
      return new le(s);
    }).catch(function(s) {
      return new de(n(s));
    });
    return new t(r);
  }, t.combine = function(e) {
    return Yr(e);
  }, t.combineWithAllErrors = function(e) {
    return Kr(e);
  }, t.prototype.map = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return at(n, void 0, void 0, function() {
        var s;
        return ut(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isErr() ? [2, new de(r.error)] : (s = le.bind, [4, e(r.value)]);
            case 1:
              return [2, new (s.apply(le, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.mapErr = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return at(n, void 0, void 0, function() {
        var s;
        return ut(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isOk() ? [2, new le(r.value)] : (s = de.bind, [4, e(r.error)]);
            case 1:
              return [2, new (s.apply(de, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.andThen = function(e) {
    return new t(this._promise.then(function(n) {
      if (n.isErr())
        return new de(n.error);
      var r = e(n.value);
      return r instanceof t ? r._promise : r;
    }));
  }, t.prototype.orElse = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return at(n, void 0, void 0, function() {
        return ut(this, function(s) {
          return r.isErr() ? [2, e(r.error)] : [2, new le(r.value)];
        });
      });
    }));
  }, t.prototype.match = function(e, n) {
    return this._promise.then(function(r) {
      return r.match(e, n);
    });
  }, t.prototype.unwrapOr = function(e) {
    return this._promise.then(function(n) {
      return n.unwrapOr(e);
    });
  }, t.prototype.then = function(e, n) {
    return this._promise.then(e, n);
  }, t;
}(), Vt = function(t) {
  return new X(Promise.resolve(new de(t)));
};
X.fromPromise;
X.fromSafePromise;
var Gr = function(t) {
  return function(e) {
    return he(he([], He(e), !1), [t], !1);
  };
}, Cn = function(t) {
  return t.reduce(function(e, n) {
    return e.isOk() ? n.isErr() ? z(n.error) : e.map(Gr(n.value)) : e;
  }, V([]));
}, Yr = function(t) {
  return X.fromSafePromise(Promise.all(t)).andThen(Cn);
}, $n = function(t) {
  return t.reduce(function(e, n) {
    return n.isErr() ? e.isErr() ? z(he(he([], He(e.error), !1), [n.error], !1)) : z([n.error]) : e.isErr() ? e : V(he(he([], He(e.value), !1), [n.value], !1));
  }, V([]));
}, Kr = function(t) {
  return X.fromSafePromise(Promise.all(t)).andThen($n);
}, ht;
(function(t) {
  function e(s, i) {
    return function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      try {
        var c = s.apply(void 0, he([], He(o), !1));
        return V(c);
      } catch (u) {
        return z(i ? i(u) : u);
      }
    };
  }
  t.fromThrowable = e;
  function n(s) {
    return Cn(s);
  }
  t.combine = n;
  function r(s) {
    return $n(s);
  }
  t.combineWithAllErrors = r;
})(ht || (ht = {}));
var V = function(t) {
  return new le(t);
}, z = function(t) {
  return new de(t);
}, le = function() {
  function t(e) {
    this.value = e;
  }
  return t.prototype.isOk = function() {
    return !0;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return V(e(this.value));
  }, t.prototype.mapErr = function(e) {
    return V(this.value);
  }, t.prototype.andThen = function(e) {
    return e(this.value);
  }, t.prototype.orElse = function(e) {
    return V(this.value);
  }, t.prototype.asyncAndThen = function(e) {
    return e(this.value);
  }, t.prototype.asyncMap = function(e) {
    return X.fromSafePromise(e(this.value));
  }, t.prototype.unwrapOr = function(e) {
    return this.value;
  }, t.prototype.match = function(e, n) {
    return e(this.value);
  }, t.prototype._unsafeUnwrap = function(e) {
    return this.value;
  }, t.prototype._unsafeUnwrapErr = function(e) {
    throw Nn("Called `_unsafeUnwrapErr` on an Ok", this, e);
  }, t;
}(), de = function() {
  function t(e) {
    this.error = e;
  }
  return t.prototype.isOk = function() {
    return !1;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return z(this.error);
  }, t.prototype.mapErr = function(e) {
    return z(e(this.error));
  }, t.prototype.andThen = function(e) {
    return z(this.error);
  }, t.prototype.orElse = function(e) {
    return e(this.error);
  }, t.prototype.asyncAndThen = function(e) {
    return Vt(this.error);
  }, t.prototype.asyncMap = function(e) {
    return Vt(this.error);
  }, t.prototype.unwrapOr = function(e) {
    return e;
  }, t.prototype.match = function(e, n) {
    return n(this.error);
  }, t.prototype._unsafeUnwrap = function(e) {
    throw Nn("Called `_unsafeUnwrap` on an Err", this, e);
  }, t.prototype._unsafeUnwrapErr = function(e) {
    return this.error;
  }, t;
}();
ht.fromThrowable;
const B = {
  extensionDetectionTime: 100,
  defaultNumberOfAccountsQuantity: 1,
  defaultNumberOfAccountsQuantifier: "atLeast",
  logLevel: "info"
}, Jr = (t) => t, pe = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
}, Qr = (/* @__PURE__ */ new Map()).set(pe.missingExtension, "extension could not be found").set(pe.rejectedByUser, "user rejected request").set(pe.canceledByUser, "user has canceled the request"), Ge = (t, e, n) => ({
  error: t,
  interactionId: e,
  message: n || Qr.get(t) || ""
}), Xr = (t) => X.fromPromise(Pr(t), Jr).andThen(
  (e) => e
), es = (t, e) => t.messageLifeCycleEventSubject.pipe(
  je((n) => n.interactionId === e)
), ts = (t) => (e) => (n) => {
  const r = new te();
  e.requestControl && e.requestControl({
    cancelRequest: () => (q.debug(
      `🔵⬆️❌ wallet request canceled
${JSON.stringify(
        n,
        null,
        2
      )}`
    ), r.next())
  });
  const s = r.asObservable().pipe(
    $e(
      () => z(Ge(pe.canceledByUser, n.interactionId))
    )
  ), i = t.responseSubject.pipe(
    je((w) => w.interactionId === n.interactionId),
    $e(
      (w) => "items" in w ? V(w) : z(w)
    )
  ), o = it(
    i,
    s
  ).pipe(Bt()), a = es(t, n.interactionId).pipe(
    Se((w) => {
      e.eventCallback && e.eventCallback(w.eventType);
    }),
    Zr(i),
    Pn()
  ), c = a.subscribe(), u = $r(B.extensionDetectionTime).pipe(
    $e(
      () => z(Ge(pe.missingExtension, n.interactionId))
    )
  ), l = it(
    u,
    a
  ).pipe(
    Bt(),
    je((w) => !("eventType" in w))
  ), _ = Ir(!0).pipe(
    Se(() => {
      t.outgoingMessageSubject.next(n);
    }),
    je(() => !1)
  ), m = it(
    o,
    l,
    _
  ).pipe(
    Se(() => {
      c.unsubscribe();
    })
  );
  return Xr(m);
};
var E;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return t.objectValues(o);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, t.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(E || (E = {}));
const f = E.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), fe = (t) => {
  switch (typeof t) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(t) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "object":
      return Array.isArray(t) ? f.array : t === null ? f.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? f.promise : typeof Map < "u" && t instanceof Map ? f.map : typeof Set < "u" && t instanceof Set ? f.set : typeof Date < "u" && t instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, d = E.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
class re extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let a = r, c = 0;
          for (; c < o.path.length; ) {
            const u = o.path[c];
            c === o.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(o))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, E.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
re.create = (t) => new re(t);
const Ye = (t, e) => {
  let n;
  switch (t.code) {
    case d.invalid_type:
      t.received === f.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, E.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${E.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      n = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${E.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      n = `Invalid enum value. Expected ${E.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      n = "Invalid function return type";
      break;
    case d.invalid_date:
      n = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : E.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be greater than ${t.inclusive ? "or equal to " : ""}${t.minimum}` : t.type === "date" ? n = `Date must be greater than ${t.inclusive ? "or equal to " : ""}${new Date(t.minimum)}` : n = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be less than ${t.inclusive ? "or equal to " : ""}${t.maximum}` : t.type === "date" ? n = `Date must be smaller than ${t.inclusive ? "or equal to " : ""}${new Date(t.maximum)}` : n = "Invalid input";
      break;
    case d.custom:
      n = "Invalid input";
      break;
    case d.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    default:
      n = e.defaultError, E.assertNever(t);
  }
  return { message: n };
};
let ns = Ye;
function pt() {
  return ns;
}
const mt = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, i = [...n, ...s.path || []], o = {
    ...s,
    path: i
  };
  let a = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: s.message || a
  };
};
function h(t, e) {
  const n = mt({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      pt(),
      Ye
    ].filter((r) => !!r)
  });
  t.common.issues.push(n);
}
class L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return g;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return L.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return g;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const g = Object.freeze({
  status: "aborted"
}), M = (t) => ({ status: "valid", value: t }), zt = (t) => t.status === "aborted", Ht = (t) => t.status === "dirty", yt = (t) => t.status === "valid", Gt = (t) => typeof Promise !== void 0 && t instanceof Promise;
var O;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(O || (O = {}));
class G {
  constructor(e, n, r, s) {
    this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
}
const Yt = (t, e) => {
  if (yt(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: !1, error: new re(t.common.issues) };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: r ?? a.defaultError } : { message: n ?? a.defaultError }, description: s };
}
class T {
  constructor(e) {
    this.spa = this.safeParseAsync, this.superRefine = this._refinement, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return fe(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: fe(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new L(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: fe(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Gt(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: fe(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return Yt(s, i);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: fe(e)
    }, s = this._parse({ data: e, path: [], parent: r }), i = await (Gt(s) ? s : Promise.resolve(s));
    return Yt(r, i);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: d.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new ie({
      schema: this,
      typeName: v.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  optional() {
    return K.create(this);
  }
  nullable() {
    return Pe.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return J.create(this);
  }
  promise() {
    return De.create(this);
  }
  or(e) {
    return Ke.create([this, e]);
  }
  and(e) {
    return Je.create(this, e);
  }
  transform(e) {
    return new ie({
      schema: this,
      typeName: v.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new Ln({
      innerType: this,
      defaultValue: n,
      typeName: v.ZodDefault
    });
  }
  brand() {
    return new as({
      typeName: v.ZodBranded,
      type: this,
      ...b(void 0)
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const rs = /^c[^\s-]{8,}$/i, ss = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, is = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ve extends T {
  constructor() {
    super(...arguments), this._regex = (e, n, r) => this.refinement((s) => e.test(s), {
      validation: n,
      code: d.invalid_string,
      ...O.errToObj(r)
    }), this.nonempty = (e) => this.min(1, O.errToObj(e)), this.trim = () => new ve({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._getType(e) !== f.string) {
      const i = this._getOrReturnCtx(e);
      return h(
        i,
        {
          code: d.invalid_type,
          expected: f.string,
          received: i.parsedType
        }
      ), g;
    }
    const r = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "email")
        is.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        ss.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        rs.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), h(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : E.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _addCheck(e) {
    return new ve({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...O.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...O.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...O.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...O.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...O.errToObj(n)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...O.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...O.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...O.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...O.errToObj(n)
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
ve.create = (t) => new ve({
  checks: [],
  typeName: v.ZodString,
  ...b(t)
});
function os(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, i = parseInt(t.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class ke extends T {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._getType(e) !== f.number) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.number,
        received: i.parsedType
      }), g;
    }
    let r;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? E.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? os(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : E.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, O.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, O.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, O.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, O.toString(n));
  }
  setLimit(e, n, r, s) {
    return new ke({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: O.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new ke({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: O.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: O.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: O.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: O.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: O.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: O.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int");
  }
}
ke.create = (t) => new ke({
  checks: [],
  typeName: v.ZodNumber,
  ...b(t)
});
class vt extends T {
  _parse(e) {
    if (this._getType(e) !== f.bigint) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.bigint,
        received: r.parsedType
      }), g;
    }
    return M(e.data);
  }
}
vt.create = (t) => new vt({
  typeName: v.ZodBigInt,
  ...b(t)
});
class gt extends T {
  _parse(e) {
    if (this._getType(e) !== f.boolean) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.boolean,
        received: r.parsedType
      }), g;
    }
    return M(e.data);
  }
}
gt.create = (t) => new gt({
  typeName: v.ZodBoolean,
  ...b(t)
});
class Me extends T {
  _parse(e) {
    if (this._getType(e) !== f.date) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.date,
        received: i.parsedType
      }), g;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_date
      }), g;
    }
    const r = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_small,
        message: i.message,
        inclusive: !0,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_big,
        message: i.message,
        inclusive: !0,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : E.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Me({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: O.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: O.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Me.create = (t) => new Me({
  checks: [],
  typeName: v.ZodDate,
  ...b(t)
});
class _t extends T {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.undefined,
        received: r.parsedType
      }), g;
    }
    return M(e.data);
  }
}
_t.create = (t) => new _t({
  typeName: v.ZodUndefined,
  ...b(t)
});
class bt extends T {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.null,
        received: r.parsedType
      }), g;
    }
    return M(e.data);
  }
}
bt.create = (t) => new bt({
  typeName: v.ZodNull,
  ...b(t)
});
class wt extends T {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return M(e.data);
  }
}
wt.create = (t) => new wt({
  typeName: v.ZodAny,
  ...b(t)
});
class Oe extends T {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return M(e.data);
  }
}
Oe.create = (t) => new Oe({
  typeName: v.ZodUnknown,
  ...b(t)
});
class se extends T {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return h(n, {
      code: d.invalid_type,
      expected: f.never,
      received: n.parsedType
    }), g;
  }
}
se.create = (t) => new se({
  typeName: v.ZodNever,
  ...b(t)
});
class xt extends T {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.void,
        received: r.parsedType
      }), g;
    }
    return M(e.data);
  }
}
xt.create = (t) => new xt({
  typeName: v.ZodVoid,
  ...b(t)
});
class J extends T {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== f.array)
      return h(n, {
        code: d.invalid_type,
        expected: f.array,
        received: n.parsedType
      }), g;
    if (s.minLength !== null && n.data.length < s.minLength.value && (h(n, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (h(n, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(n.data.map((o, a) => s.type._parseAsync(new G(n, o, n.path, a)))).then((o) => L.mergeArray(r, o));
    const i = n.data.map((o, a) => s.type._parseSync(new G(n, o, n.path, a)));
    return L.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new J({
      ...this._def,
      minLength: { value: e, message: O.toString(n) }
    });
  }
  max(e, n) {
    return new J({
      ...this._def,
      maxLength: { value: e, message: O.toString(n) }
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
J.create = (t, e) => new J({
  type: t,
  minLength: null,
  maxLength: null,
  typeName: v.ZodArray,
  ...b(e)
});
var Tt;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
  });
})(Tt || (Tt = {}));
const Kt = (t) => (e) => new P({
  ...t,
  shape: () => ({
    ...t.shape(),
    ...e
  })
});
function xe(t) {
  if (t instanceof P) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = K.create(xe(r));
    }
    return new P({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof J ? J.create(xe(t.element)) : t instanceof K ? K.create(xe(t.unwrap())) : t instanceof Pe ? Pe.create(xe(t.unwrap())) : t instanceof Q ? Q.create(t.items.map((e) => xe(e))) : t;
}
class P extends T {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = Kt(this._def), this.extend = Kt(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = E.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const u = this._getOrReturnCtx(e);
      return h(u, {
        code: d.invalid_type,
        expected: f.object,
        received: u.parsedType
      }), g;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof se && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        o.includes(u) || a.push(u);
    const c = [];
    for (const u of o) {
      const l = i[u], _ = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new G(s, _, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof se) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of a)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        a.length > 0 && (h(s, {
          code: d.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of a) {
        const _ = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new G(s, _, s.path, l)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const _ = await l.key;
        u.push({
          key: _,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => L.mergeObjectSync(r, u)) : L.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return O.errToObj, new P({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var s, i, o, a;
          const c = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = O.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new P({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new P({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  merge(e) {
    return new P({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => Tt.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: v.ZodObject
    });
  }
  catchall(e) {
    return new P({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return E.objectKeys(e).map((r) => {
      this.shape[r] && (n[r] = this.shape[r]);
    }), new P({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return E.objectKeys(this.shape).map((r) => {
      E.objectKeys(e).indexOf(r) === -1 && (n[r] = this.shape[r]);
    }), new P({
      ...this._def,
      shape: () => n
    });
  }
  deepPartial() {
    return xe(this);
  }
  partial(e) {
    const n = {};
    if (e)
      return E.objectKeys(this.shape).map((r) => {
        E.objectKeys(e).indexOf(r) === -1 ? n[r] = this.shape[r] : n[r] = this.shape[r].optional();
      }), new P({
        ...this._def,
        shape: () => n
      });
    for (const r in this.shape) {
      const s = this.shape[r];
      n[r] = s.optional();
    }
    return new P({
      ...this._def,
      shape: () => n
    });
  }
  required() {
    const e = {};
    for (const n in this.shape) {
      let s = this.shape[n];
      for (; s instanceof K; )
        s = s._def.innerType;
      e[n] = s;
    }
    return new P({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return jn(E.objectKeys(this.shape));
  }
}
P.create = (t, e) => new P({
  shape: () => t,
  unknownKeys: "strip",
  catchall: se.create(),
  typeName: v.ZodObject,
  ...b(e)
});
P.strictCreate = (t, e) => new P({
  shape: () => t,
  unknownKeys: "strict",
  catchall: se.create(),
  typeName: v.ZodObject,
  ...b(e)
});
P.lazycreate = (t, e) => new P({
  shape: t,
  unknownKeys: "strip",
  catchall: se.create(),
  typeName: v.ZodObject,
  ...b(e)
});
class Ke extends T {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new re(a.ctx.common.issues));
      return h(n, {
        code: d.invalid_union,
        unionErrors: o
      }), g;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && o.push(u.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new re(c));
      return h(n, {
        code: d.invalid_union,
        unionErrors: a
      }), g;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ke.create = (t, e) => new Ke({
  options: t,
  typeName: v.ZodUnion,
  ...b(e)
});
class jt extends T {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.object)
      return h(n, {
        code: d.invalid_type,
        expected: f.object,
        received: n.parsedType
      }), g;
    const r = this.discriminator, s = n.data[r], i = this.options.get(s);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (h(n, {
      code: d.invalid_union_discriminator,
      options: this.validDiscriminatorValues,
      path: [r]
    }), g);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(e, n, r) {
    const s = /* @__PURE__ */ new Map();
    try {
      n.forEach((i) => {
        const o = i.shape[e].value;
        s.set(o, i);
      });
    } catch {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (s.size !== n.length)
      throw new Error("Some of the discriminator values are not unique");
    return new jt({
      typeName: v.ZodDiscriminatedUnion,
      discriminator: e,
      options: s,
      ...b(r)
    });
  }
}
function St(t, e) {
  const n = fe(t), r = fe(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === f.object && r === f.object) {
    const s = E.objectKeys(e), i = E.objectKeys(t).filter((a) => s.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const c = St(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === f.array && r === f.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], c = St(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return n === f.date && r === f.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Je extends T {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (i, o) => {
      if (zt(i) || zt(o))
        return g;
      const a = St(i.value, o.value);
      return a.valid ? ((Ht(i) || Ht(o)) && n.dirty(), { status: n.value, value: a.data }) : (h(r, {
        code: d.invalid_intersection_types
      }), g);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Je.create = (t, e, n) => new Je({
  left: t,
  right: e,
  typeName: v.ZodIntersection,
  ...b(n)
});
class Q extends T {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.array)
      return h(r, {
        code: d.invalid_type,
        expected: f.array,
        received: r.parsedType
      }), g;
    if (r.data.length < this._def.items.length)
      return h(r, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        type: "array"
      }), g;
    !this._def.rest && r.data.length > this._def.items.length && (h(r, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      type: "array"
    }), n.dirty());
    const i = r.data.map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new G(r, o, r.path, a)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => L.mergeArray(n, o)) : L.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Q({
      ...this._def,
      rest: e
    });
  }
}
Q.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Q({
    items: t,
    typeName: v.ZodTuple,
    rest: null,
    ...b(e)
  });
};
class Qe extends T {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.object)
      return h(r, {
        code: d.invalid_type,
        expected: f.object,
        received: r.parsedType
      }), g;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in r.data)
      s.push({
        key: i._parse(new G(r, a, r.path, a)),
        value: o._parse(new G(r, r.data[a], r.path, a))
      });
    return r.common.async ? L.mergeObjectAsync(n, s) : L.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof T ? new Qe({
      keyType: e,
      valueType: n,
      typeName: v.ZodRecord,
      ...b(r)
    }) : new Qe({
      keyType: ve.create(),
      valueType: e,
      typeName: v.ZodRecord,
      ...b(n)
    });
  }
}
class Ot extends T {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.map)
      return h(r, {
        code: d.invalid_type,
        expected: f.map,
        received: r.parsedType
      }), g;
    const s = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, c], u) => ({
      key: s._parse(new G(r, a, r.path, [u, "key"])),
      value: i._parse(new G(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return g;
          (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return g;
        (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Ot.create = (t, e, n) => new Ot({
  valueType: e,
  keyType: t,
  typeName: v.ZodMap,
  ...b(n)
});
class Ie extends T {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.set)
      return h(r, {
        code: d.invalid_type,
        expected: f.set,
        received: r.parsedType
      }), g;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (h(r, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (h(r, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return g;
        l.status === "dirty" && n.dirty(), u.add(l.value);
      }
      return { status: n.value, value: u };
    }
    const a = [...r.data.values()].map((c, u) => i._parse(new G(r, c, r.path, u)));
    return r.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, n) {
    return new Ie({
      ...this._def,
      minSize: { value: e, message: O.toString(n) }
    });
  }
  max(e, n) {
    return new Ie({
      ...this._def,
      maxSize: { value: e, message: O.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Ie.create = (t, e) => new Ie({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: v.ZodSet,
  ...b(e)
});
class Le extends T {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.function)
      return h(n, {
        code: d.invalid_type,
        expected: f.function,
        received: n.parsedType
      }), g;
    function r(a, c) {
      return mt({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          pt(),
          Ye
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(a, c) {
      return mt({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          pt(),
          Ye
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    return this._def.returns instanceof De ? M(async (...a) => {
      const c = new re([]), u = await this._def.args.parseAsync(a, i).catch((m) => {
        throw c.addIssue(r(a, m)), c;
      }), l = await o(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((m) => {
        throw c.addIssue(s(l, m)), c;
      });
    }) : M((...a) => {
      const c = this._def.args.safeParse(a, i);
      if (!c.success)
        throw new re([r(a, c.error)]);
      const u = o(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new re([s(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Le({
      ...this._def,
      args: Q.create(e).rest(Oe.create())
    });
  }
  returns(e) {
    return new Le({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new Le({
      args: e || Q.create([]).rest(Oe.create()),
      returns: n || Oe.create(),
      typeName: v.ZodFunction,
      ...b(r)
    });
  }
}
class At extends T {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
At.create = (t, e) => new At({
  getter: t,
  typeName: v.ZodLazy,
  ...b(e)
});
class Et extends T {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_literal,
        expected: this._def.value
      }), g;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Et.create = (t, e) => new Et({
  value: t,
  typeName: v.ZodLiteral,
  ...b(e)
});
function jn(t, e) {
  return new Lt({
    values: t,
    typeName: v.ZodEnum,
    ...b(e)
  });
}
class Lt extends T {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        expected: E.joinValues(r),
        received: n.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: r
      }), g;
    }
    return M(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
}
Lt.create = jn;
class kt extends T {
  _parse(e) {
    const n = E.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== f.string && r.parsedType !== f.number) {
      const s = E.objectValues(n);
      return h(r, {
        expected: E.joinValues(s),
        received: r.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (n.indexOf(e.data) === -1) {
      const s = E.objectValues(n);
      return h(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: s
      }), g;
    }
    return M(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
kt.create = (t, e) => new kt({
  values: t,
  typeName: v.ZodNativeEnum,
  ...b(e)
});
class De extends T {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.promise && n.common.async === !1)
      return h(n, {
        code: d.invalid_type,
        expected: f.promise,
        received: n.parsedType
      }), g;
    const r = n.parsedType === f.promise ? n.data : Promise.resolve(n.data);
    return M(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
De.create = (t, e) => new De({
  type: t,
  typeName: v.ZodPromise,
  ...b(e)
});
class ie extends T {
  innerType() {
    return this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const o = s.transform(r.data);
      return r.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    const i = {
      addIssue: (o) => {
        h(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const o = (a) => {
        const c = s.refinement(a, i);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? g : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? g : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!yt(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => yt(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    E.assertNever(s);
  }
}
ie.create = (t, e, n) => new ie({
  schema: t,
  typeName: v.ZodEffects,
  effect: e,
  ...b(n)
});
ie.createWithPreprocess = (t, e, n) => new ie({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: v.ZodEffects,
  ...b(n)
});
class K extends T {
  _parse(e) {
    return this._getType(e) === f.undefined ? M(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
K.create = (t, e) => new K({
  innerType: t,
  typeName: v.ZodOptional,
  ...b(e)
});
class Pe extends T {
  _parse(e) {
    return this._getType(e) === f.null ? M(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Pe.create = (t, e) => new Pe({
  innerType: t,
  typeName: v.ZodNullable,
  ...b(e)
});
class Ln extends T {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === f.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ln.create = (t, e) => new K({
  innerType: t,
  typeName: v.ZodOptional,
  ...b(e)
});
class It extends T {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.nan,
        received: r.parsedType
      }), g;
    }
    return { status: "valid", value: e.data };
  }
}
It.create = (t) => new It({
  typeName: v.ZodNaN,
  ...b(t)
});
class as extends T {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
P.lazycreate;
var v;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded";
})(v || (v = {}));
const N = ve.create, tt = ke.create;
It.create;
vt.create;
const Xe = gt.create;
Me.create;
_t.create;
bt.create;
wt.create;
Oe.create;
se.create;
xt.create;
J.create;
const S = P.create;
P.strictCreate;
const D = Ke.create;
jt.create;
Je.create;
Q.create;
Qe.create;
Ot.create;
Ie.create;
Le.create;
At.create;
const y = Et.create;
Lt.create;
kt.create;
De.create;
ie.create;
K.create;
Pe.create;
ie.createWithPreprocess;
const be = {
  oneTimeAccounts: y("oneTimeAccounts"),
  ongoingAccounts: y("ongoingAccounts"),
  oneTimePersonaData: y("oneTimePersonaData"),
  ongoingPersonaData: y("ongoingPersonaData"),
  auth: y("auth"),
  send: y("send")
}, us = D([
  y("rejectedByUser"),
  y("wrongNetwork"),
  y("failedToPrepareTransaction"),
  y("failedToCompileTransaction"),
  y("failedToSignTransaction"),
  y("failedToSubmitTransaction"),
  y("failedToPollSubmittedTransaction"),
  y("failedToFindAccountWithEnoughFundsToLockFee"),
  y("submittedTransactionWasDuplicate"),
  y("submittedTransactionHasFailedTransactionStatus"),
  y("submittedTransactionHasRejectedTransactionStatus"),
  y("wrongAccountType"),
  y("unknownWebsite"),
  y("radixJsonNotFound"),
  y("unknownDappDefinitionAddress"),
  y("invalidPersona")
]), qe = {
  givenName: "givenName",
  familyName: "familyName",
  emailAddress: "emailAddress",
  phoneNumber: "phoneNumber"
}, Mn = D([
  y(qe.emailAddress),
  y(qe.familyName),
  y(qe.givenName),
  y(qe.phoneNumber)
]), Mt = S({
  address: N(),
  label: N(),
  appearanceId: tt()
}), Dn = S({
  account: Mt,
  challenge: N(),
  signature: N()
}), Dt = S({
  identityAddress: N(),
  label: N()
}), Zn = S({
  field: Mn,
  value: N()
});
D([
  y("exactly"),
  y("atLeast")
]);
const Un = S({
  quantifier: D([y("exactly"), y("atLeast")]),
  quantity: tt()
}), cs = S({
  networkId: tt(),
  dAppDefinitionAddress: N()
}), Wn = S({
  requiresProofOfOwnership: Xe(),
  numberOfAccounts: Un
}), ls = S({
  accounts: Dn.array()
}), ds = S({
  accounts: Mt.array()
}), qn = D([
  ls,
  ds
]), fs = S({
  requiresProofOfOwnership: Xe(),
  numberOfAccounts: Un
}), hs = S({
  accounts: Dn.array()
}), ps = S({
  accounts: Mt.array()
}), ms = D([
  hs,
  ps
]), Fn = S({
  fields: N().array()
}), Bn = S({
  fields: Zn.array()
}), ys = S({
  fields: Mn.array()
}), vs = S({
  fields: Zn.array()
}), gs = S({
  discriminator: y("usePersona"),
  identityAddress: N()
}), _s = S({
  discriminator: y("usePersona"),
  persona: Dt
}), bs = S({
  discriminator: y("login"),
  challenge: N().optional()
}), ws = S({
  discriminator: y("loginWithoutChallenge"),
  persona: Dt
}), xs = S({
  discriminator: y("loginWithChallenge"),
  persona: Dt,
  challenge: N(),
  publicKey: N(),
  signature: N()
}), Ts = D([
  ws,
  xs
]), Ss = D([
  gs,
  bs
]), Os = D([
  _s,
  Ts
]), As = S({
  accounts: Xe(),
  personaData: Xe()
}), Es = S({
  transactionManifest: N(),
  version: tt(),
  blobs: N().array().optional(),
  message: N().optional()
}), ks = S({
  transactionIntentHash: N()
}), Is = S({
  discriminator: y("unauthorizedRequest"),
  oneTimeAccounts: Wn.optional(),
  oneTimePersonaData: Fn.optional()
}), Ps = S({
  discriminator: y("authorizedRequest"),
  auth: Ss,
  oneTimeAccounts: Wn.optional(),
  ongoingAccounts: fs.optional(),
  oneTimePersonaData: Fn.optional(),
  ongoingPersonaData: ys.optional(),
  reset: As.optional()
}), Rs = D([
  Is,
  Ps
]), Ns = S({
  discriminator: y("transaction"),
  send: Es
}), Cs = D([
  Rs,
  Ns
]), $s = S({
  interactionId: N(),
  items: Cs,
  metadata: cs
}), js = S({
  discriminator: y("unauthorizedRequest"),
  oneTimeAccounts: qn.optional(),
  oneTimePersonaData: Bn.optional()
}), Ls = S({
  discriminator: y("authorizedRequest"),
  auth: Os,
  oneTimeAccounts: qn.optional(),
  ongoingAccounts: ms.optional(),
  oneTimePersonaData: Bn.optional(),
  ongoingPersonaData: vs.optional()
}), Ms = D([
  js,
  Ls
]), Ds = S({
  discriminator: y("transaction"),
  send: ks
}), Zs = D([
  Ms,
  Ds
]), Us = S({
  discriminator: y("success"),
  interactionId: N(),
  items: Zs
}), Ws = S({
  discriminator: y("failure"),
  interactionId: N(),
  error: us,
  message: N().optional()
}), qs = D([
  Us,
  Ws
]), Jt = (t) => X.fromPromise(
  $s.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr((e) => (q.error("🔵💥 invalid wallet request"), q.debug(JSON.stringify(t, null, 2)), q.debug(JSON.stringify(e, null, 2)), Ge(
  pe.walletRequestValidation,
  t.interactionId
))), Qt = (t) => X.fromPromise(
  qs.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr(() => (q.error("🔵💥 invalid wallet response"), Ge(
  pe.walletRequestValidation,
  t.interactionId
))), Xt = (t) => {
  const { discriminator: e, ...n } = t;
  return Object.entries(n).reduce((r, [s, i]) => {
    switch (s) {
      case be.auth.value: {
        const { discriminator: o, ...a } = i;
        if (o === "usePersona")
          return { ...r, persona: a.persona };
        if (o === "loginWithChallenge") {
          const { persona: c, ...u } = a;
          return { ...r, persona: c, signedChallenge: u };
        } else
          return { ...r, persona: a.persona };
      }
      case be.oneTimeAccounts.value:
        return { ...r, oneTimeAccounts: i.accounts };
      case be.ongoingAccounts.value:
        return { ...r, ongoingAccounts: i.accounts };
      case be.oneTimePersonaData.value:
        return { ...r, oneTimePersonaData: i.fields };
      case be.ongoingPersonaData.value:
        return { ...r, ongoingPersonaData: i.fields };
      case be.send.value:
        return { ...r, transactionIntentHash: i.transactionIntentHash };
      default:
        return r;
    }
  }, {});
}, W = {
  oneTimeAccountsWithoutProofOfOwnership: "oneTimeAccountsWithoutProofOfOwnership",
  oneTimeAccountsWithProofOfOwnership: "oneTimeAccountsWithProofOfOwnership",
  ongoingAccountsWithoutProofOfOwnership: "ongoingAccountsWithoutProofOfOwnership",
  ongoingAccountsWithProofOfOwnership: "ongoingAccountsWithProofOfOwnership",
  usePersona: "usePersona",
  loginWithoutChallenge: "loginWithoutChallenge",
  loginWithChallenge: "loginWithChallenge",
  oneTimePersonaData: "oneTimePersonaData",
  ongoingPersonaData: "ongoingPersonaData",
  reset: "reset"
}, Fe = (t) => ({
  quantity: (t == null ? void 0 : t.quantity) || 1,
  quantifier: (t == null ? void 0 : t.quantifier) || "atLeast"
}), Fs = (t) => {
  if (t.discriminator === "transaction" || t.discriminator === "authorizedRequest")
    return t;
  const { reset: e, ...n } = t;
  return n;
}, en = (t) => V(
  Object.entries(t).reduce(
    (e, [n, r]) => {
      switch (n) {
        case W.oneTimeAccountsWithoutProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: Fe(r)
            }
          };
        case W.oneTimeAccountsWithProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: Fe(r)
            }
          };
        case W.ongoingAccountsWithProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: Fe(r)
            }
          };
        case W.ongoingAccountsWithoutProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: Fe(r)
            }
          };
        case W.oneTimePersonaData:
          return {
            ...e,
            oneTimePersonaData: {
              fields: r.fields
            }
          };
        case W.ongoingPersonaData:
          return {
            ...e,
            ongoingPersonaData: {
              fields: r.fields
            }
          };
        case W.loginWithoutChallenge:
          return {
            ...e,
            auth: { ...r, discriminator: "login" },
            discriminator: "authorizedRequest"
          };
        case W.usePersona:
          return {
            ...e,
            auth: { ...r, discriminator: "usePersona" },
            discriminator: "authorizedRequest"
          };
        case W.loginWithChallenge:
          return {
            ...e,
            auth: r,
            discriminator: "authorizedRequest"
          };
        case W.reset: {
          const { accounts: s = !1, personaData: i = !1 } = r;
          return !s && !i ? e : {
            ...e,
            reset: { accounts: s, personaData: i }
          };
        }
        case "send":
          return {
            discriminator: "transaction",
            send: r
          };
        default:
          return {
            ...e,
            [n]: r
          };
      }
    },
    {
      discriminator: "unauthorizedRequest"
    }
  )
).map(Fs), tn = (t) => (e, n = crypto.randomUUID()) => V({
  items: e,
  interactionId: n,
  metadata: t
}), Bs = {
  send: "send"
}, Vs = {
  ...W,
  ...Bs
}, zs = (t, e) => ({
  request: (s, i = {}) => en(s).andThen(tn(t)).asyncAndThen(Jt).andThen(e(i)).andThen(Qt).map((o) => o.items).map(Xt),
  sendTransaction: (s, i = {}) => en({ [Vs.send]: s }).andThen(tn(t)).asyncAndThen(Jt).andThen(e(i)).andThen(Qt).map((o) => o.items).map(Xt)
});
var Hs = /* @__PURE__ */ ((t) => (t.Bool = "Bool", t.I8 = "i8", t.I16 = "i16", t.I32 = "i32", t.I64 = "i64", t.I128 = "i128", t.U8 = "u8", t.U16 = "u16", t.U32 = "u32", t.U64 = "u64", t.U128 = "u128", t.Unit = "Unit", t.String = "String", t.Enum = "Enum", t.Array = "Array", t.Tuple = "Tuple", t.Map = "Map", t.Address = "Address", t.Bucket = "Bucket", t.Proof = "Proof", t.Expression = "Expression", t.Blob = "Blob", t.Decimal = "Decimal", t.PreciseDecimal = "PreciseDecimal", t.NonFungibleLocalId = "NonFungibleLocalId", t.NonFungibleGlobalId = "NonFungibleGlobalId", t.Bytes = "Bytes", t))(Hs || {});
class Z extends Error {
  constructor(e) {
    super(e);
  }
}
const Pi = () => "()", Ri = (t) => `${t}`, Ni = (t) => {
  if (t < -128 || t > 127)
    throw new Z("Number range exceeded i8");
  return `${t}i8`;
}, Ci = (t) => {
  if (t < -32768 || t > 32767)
    throw new Z("Number range exceeded i16");
  return `${t}i16`;
}, $i = (t) => {
  if (t < -2147483648 || t > 2147483647)
    throw new Z("Number range exceeded i32");
  return `${t}i32`;
}, ji = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-9223372036854775808") || e > BigInt("9223372036854775807"))
    throw new Z("Number range exceeded i64");
  return `${t}i64`;
}, Li = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-170141183460469231731687303715884105728") || e > BigInt("170141183460469231731687303715884105727"))
    throw new Z("Number range exceeded i128");
  return `${t}i128`;
}, Mi = (t) => {
  if (t < 0 || t > 255)
    throw new Z("Number range exceeded u8");
  return `${t}u8`;
}, Di = (t) => {
  if (t < 0 || t > 65535)
    throw new Z("Number range exceeded u16");
  return `${t}u16`;
}, Zi = (t) => {
  if (t < 0 || t > 4294967295)
    throw new Z("Number range exceeded u32");
  return `${t}u32`;
}, Ui = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("18446744073709551615"))
    throw new Z("Number range exceeded u64");
  return `${t}u64`;
}, Wi = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("340282366920938463463374607431768211455"))
    throw new Z("Number range exceeded u128");
  return `${t}u128`;
}, qi = (t) => `"${t}"`, Fi = (t, ...e) => typeof t == "number" ? e.length > 0 ? `Enum(${t}u8, ${e.join(", ")})` : `Enum(${t}u8)` : e.length > 0 ? `Enum("${t}", ${e.join(", ")})` : `Enum("${t}")`, Bi = (...t) => `Tuple(${t.join(",")})`, Vi = (t, ...e) => (Gs(t, e), `Array<${t}>(${e.join(",")})`), zi = (t, e, ...n) => `Map<${t},${e}>(${n.join(",")})`, R = (t) => `Address("${t}")`, Ne = (t) => typeof t == "string" ? `Bucket("${t}")` : `Bucket(${t}u32)`, Y = (t) => typeof t == "string" ? `Proof("${t}")` : `Proof(${t}u32)`, Hi = (t) => `Expression("${t}")`, Gi = (t) => `Blob("${t}")`, we = (t) => `Decimal("${t}")`, Yi = (t) => `PreciseDecimal("${t}")`, Ki = {
  String: (t) => `NonFungibleLocalId("<${t}>")`,
  Integer: (t) => `NonFungibleLocalId("#${t}#")`,
  Byte: (t) => `NonFungibleLocalId("[${t}]")`,
  Uuid: (t) => `NonFungibleLocalId("{${t}}")`
}, Ji = (t) => `NonFungibleGlobalId("${t}")`, Qi = (t) => `Bytes("${t}")`, Gs = (t, e) => {
  if (t === "String") {
    if (e.some((n) => !n.startsWith('"') && !n.endsWith('"')))
      throw new Z(`Array<${t}> expects the same type`);
  } else if (t === "Unit") {
    if (e.some((n) => n !== "()"))
      throw new Z(`Array<${t}> expects the same type`);
  } else if (e.some((n) => !n.includes(t)))
    throw new Z(`Array<${t}> expects the same type`);
};
class Ys {
  constructor(e) {
    _e(this, "instructions");
    this.instructions = e;
  }
  toString() {
    return this.instructions.join(`
`);
  }
}
class Xi {
  constructor() {
    _e(this, "instructions");
    _e(this, "buckets");
    _e(this, "proofs");
    _e(this, "id_allocator");
    this.instructions = [], this.buckets = /* @__PURE__ */ new Map(), this.proofs = /* @__PURE__ */ new Map(), this.id_allocator = 512;
  }
  takeFromWorktop(e, n) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP ${R(e)} ${Ne(n)};`
    ), this.buckets.set(n, this.id_allocator++), this;
  }
  takeFromWorktopByAmount(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_AMOUNT ${we(e)} ${R(
        n
      )} ${Ne(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  takeFromWorktopByIds(e, n, r) {
    let s = e.map(function(i) {
      return 'NonFungibleLocalId("' + i + '")';
    }).join(", ");
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_IDS Array<NonFungibleLocalId>(${s}) ${R(
        n
      )} ${Ne(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  returnToWorktop(e) {
    return this.instructions.push(`RETURN_TO_WORKTOP ${Ne(e)};`), this;
  }
  assertWorktopContains(e) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS ${R(e)};`
    ), this;
  }
  assertWorktopContainsByAmount(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_AMOUNT ${we(e)} ${R(
        n
      )};`
    ), this;
  }
  assertWorktopContainsByIds(e, n) {
    let r = e.map(function(s) {
      return 'NonFungibleLocalId("' + s + '")';
    }).join(", ");
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_IDS Array<NonFungibleLocalId>(${r}) ${R(
        n
      )};`
    ), this;
  }
  popFromAuthZone(e) {
    return this.instructions.push(`POP_FROM_AUTH_ZONE ${Y(e)};`), this.proofs.set(e, this.id_allocator++), this;
  }
  pushToAuthZone(e) {
    return this.instructions.push(`PUSH_TO_AUTH_ZONE ${Y(e)};`), this;
  }
  clearAuthZone() {
    return this.instructions.push("CLEAR_AUTH_ZONE;"), this;
  }
  createProofFromAuthZone(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE ${R(e)} ${Y(
        n
      )};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  createProofFromAuthZoneByAmount(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT ${we(e)} ${R(
        n
      )} ${Y(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromAuthZoneByIds(e, n, r) {
    let s = e.map(function(i) {
      return 'NonFungibleLocalId("' + i + '")';
    }).join(", ");
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS Array<NonFungibleLocalId>(${s}) ${R(
        n
      )} ${Y(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromBucket(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_BUCKET ${Ne(e)} ${Y(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  cloneProof(e, n) {
    return this.instructions.push(
      `CLONE_PROOF ${Y(e)} ${Y(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  dropProof(e) {
    return this.instructions.push(`DROP_PROOF ${Y(e)};`), this;
  }
  callFunction(e, n, r, s) {
    return this.instructions.push(
      `CALL_FUNCTION ${R(
        e
      )} "${n}" "${r}" ${s.join(" ")};`
    ), this;
  }
  callMethod(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${R(e)} "${n}" ${r.join(
        " "
      )};`
    ), this;
  }
  mintFungible(e, n) {
    return this.instructions.push(
      `MINT_FUNGIBLE ${R(e)} ${we(n)};`
    ), this;
  }
  withdrawFromAccount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${R(e)} "withdraw" ${R(
        n
      )} ${we(r)};`
    ), this;
  }
  withdrawNonFungiblesFromAccount(e, n, r) {
    let s = r.map(function(i) {
      return 'NonFungibleLocalId("' + i + '")';
    }).join(", ");
    return this.instructions.push(
      `CALL_METHOD ${R(
        e
      )} "withdraw_non_fungibles" ${R(
        n
      )} Array<NonFungibleLocalId>(${s});`
    ), this;
  }
  createProofFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${R(e)} "create_proof" ${R(
        n
      )};`
    ), this;
  }
  createProofFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${R(
        e
      )} "create_proof_by_amount" ${R(n)} ${we(
        r
      )};`
    ), this;
  }
  createProofFromAccountByIds(e, n, r) {
    let s = r.map(function(i) {
      return 'NonFungibleLocalId("' + i + '")';
    }).join(", ");
    return this.instructions.push(
      `CALL_METHOD ${R(e)} "create_proof_by_ids" ${R(
        n
      )} Array<NonFungibleLocalId>(${s});`
    ), this;
  }
  instruction(e, n) {
    return this.instructions.push(`${e} ${n.join(" ")};`), this;
  }
  build() {
    return new Ys(this.instructions);
  }
}
var Ks = "Expected a function", Js = 9007199254740991, Qs = "[object Arguments]", Xs = "[object Function]", ei = "[object GeneratorFunction]", ti = typeof Ce == "object" && Ce && Ce.Object === Object && Ce, ni = typeof self == "object" && self && self.Object === Object && self, ri = ti || ni || Function("return this")();
function si(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function ii(t, e) {
  for (var n = -1, r = e.length, s = t.length; ++n < r; )
    t[s + n] = e[n];
  return t;
}
var Zt = Object.prototype, oi = Zt.hasOwnProperty, Vn = Zt.toString, nn = ri.Symbol, ai = Zt.propertyIsEnumerable, rn = nn ? nn.isConcatSpreadable : void 0, sn = Math.max;
function zn(t, e, n, r, s) {
  var i = -1, o = t.length;
  for (n || (n = li), s || (s = []); ++i < o; ) {
    var a = t[i];
    e > 0 && n(a) ? e > 1 ? zn(a, e - 1, n, r, s) : ii(s, a) : r || (s[s.length] = a);
  }
  return s;
}
function ui(t, e) {
  return e = sn(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, r = -1, s = sn(n.length - e, 0), i = Array(s); ++r < s; )
      i[r] = n[e + r];
    r = -1;
    for (var o = Array(e + 1); ++r < e; )
      o[r] = n[r];
    return o[e] = i, si(t, this, o);
  };
}
function ci(t) {
  return ui(function(e) {
    e = zn(e, 1);
    var n = e.length, r = n;
    for (t && e.reverse(); r--; )
      if (typeof e[r] != "function")
        throw new TypeError(Ks);
    return function() {
      for (var s = 0, i = n ? e[s].apply(this, arguments) : arguments[0]; ++s < n; )
        i = e[s].call(this, i);
      return i;
    };
  });
}
function li(t) {
  return fi(t) || di(t) || !!(rn && t && t[rn]);
}
function di(t) {
  return pi(t) && oi.call(t, "callee") && (!ai.call(t, "callee") || Vn.call(t) == Qs);
}
var fi = Array.isArray;
function hi(t) {
  return t != null && yi(t.length) && !mi(t);
}
function pi(t) {
  return gi(t) && hi(t);
}
function mi(t) {
  var e = vi(t) ? Vn.call(t) : "";
  return e == Xs || e == ei;
}
function yi(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Js;
}
function vi(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function gi(t) {
  return !!t && typeof t == "object";
}
var _i = ci(), bi = _i;
function eo(...t) {
  return bi(t)({});
}
const wi = {
  withoutChallenge: () => (t) => ({
    ...t,
    loginWithoutChallenge: {
      discriminator: "login"
    }
  }),
  withChallenge: (t) => (e) => ({
    ...e,
    loginWithChallenge: { discriminator: "login", challenge: t }
  })
}, xi = {
  withoutProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, Ti = (...t) => (e) => ({
  ...e,
  oneTimePersonaData: { fields: t }
}), Si = {
  withoutProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, Oi = (...t) => (e) => ({
  ...e,
  ongoingPersonaData: { fields: t }
}), Ai = (t) => (e) => ({
  ...e,
  usePersona: { discriminator: "usePersona", identityAddress: t }
}), Ei = ({ accounts: t = !1, personaData: e = !1 }) => (n) => ({
  ...n,
  reset: { accounts: t, personaData: e }
}), to = {
  oneTimeAccounts: xi,
  ongoingAccounts: Si,
  oneTimePersonaData: Ti,
  ongoingPersonaData: Oi,
  login: wi,
  usePersona: Ai,
  reset: Ei
}, ki = {
  Mainnet: 1,
  Stokenet: 2,
  Adapanet: 10,
  Nebunet: 11,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34
}, no = ({
  networkId: t = ki.Mainnet,
  dAppDefinitionAddress: e,
  logLevel: n = B.logLevel
}) => {
  q.setLevel(n), q.debug("🔵 wallet sdk instantiated");
  const r = zr(), s = () => {
    q.debug("🔵🧹 destroying wallet sdk instance"), r.destroy();
  };
  return {
    ...zs(
      { networkId: t, dAppDefinitionAddress: e },
      ts(r.subjects)
    ),
    destroy: s,
    __subjects: r.subjects
  };
};
export {
  R as Address,
  Vi as Array,
  Ts as AuthLoginRequestResponseItemSchema,
  Ss as AuthRequestItemSchema,
  Gi as Blob,
  Ri as Bool,
  Ne as Bucket,
  Qi as Bytes,
  we as Decimal,
  Fi as Enum,
  us as ErrorTypeSchema,
  Hi as Expression,
  Li as I128,
  Ci as I16,
  $i as I32,
  ji as I64,
  Ni as I8,
  Xi as ManifestBuilder,
  Z as ManifestValueError,
  zi as Map,
  ki as Network,
  Ji as NonFungibleGlobalId,
  Ki as NonFungibleLocalId,
  qn as OneTimeAccountsRequestResponseItemSchema,
  Mn as PersonaDataFieldSchema,
  Yi as PreciseDecimal,
  Y as Proof,
  be as RequestTypeSchema,
  qi as String,
  Bi as Tuple,
  Hs as TypeId,
  Wi as U128,
  Di as U16,
  Zi as U32,
  Ui as U64,
  Mi as U8,
  Pi as Unit,
  Ls as WalletAuthorizedRequestResponseItemsSchema,
  Ws as WalletInteractionFailureResponseSchema,
  Zs as WalletInteractionResponseItemsSchema,
  qs as WalletInteractionResponseSchema,
  $s as WalletInteractionSchema,
  Us as WalletInteractionSuccessResponseSchema,
  Rs as WalletRequestItemsSchema,
  Ms as WalletRequestResponseItemsSchema,
  no as WalletSdk,
  Ds as WalletTransactionResponseItemsSchema,
  js as WalletUnauthorizedRequestResponseItemsSchema,
  Ge as createSdkError,
  pe as errorType,
  wi as login,
  xi as oneTimeAccounts,
  Ti as oneTimePersonaData,
  Si as ongoingAccounts,
  Oi as ongoingPersonaData,
  qe as personaDataField,
  eo as requestBuilder,
  to as requestItem,
  Jr as sdkError,
  Ai as usePersona
};
