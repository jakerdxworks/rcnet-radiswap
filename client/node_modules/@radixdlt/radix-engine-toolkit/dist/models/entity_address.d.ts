import { IAddress } from "../base/base_address";
import { PublicKey } from "./crypto";
export declare class EntityAddress {
    readonly type: "ComponentAddress" | "ResourceAddress" | "PackageAddress";
    constructor(type: "ComponentAddress" | "ResourceAddress" | "PackageAddress");
}
export declare class ComponentAddress extends EntityAddress implements IAddress {
    address: string;
    constructor(address: string);
    static virtualAccountAddress(publicKey: PublicKey.PublicKey, networkId: number): Promise<ComponentAddress>;
    static virtualIdentityAddress(publicKey: PublicKey.PublicKey, networkId: number): Promise<ComponentAddress>;
    static fromOlympiaAccountAddress(olympiaAccountAddress: string, networkId: number): Promise<ComponentAddress>;
    static decode(bytes: Uint8Array | string, networkId: number): Promise<ComponentAddress>;
    static faucetComponentAddress(networkId: number): Promise<ComponentAddress>;
    static epochManagerComponentAddress(networkId: number): Promise<ComponentAddress>;
    static clockComponentAddress(networkId: number): Promise<ComponentAddress>;
    networkId(): Promise<number>;
    networkName(): Promise<string>;
    entityType(): Promise<EntityType>;
    data(): Promise<Uint8Array>;
    hrp(): Promise<string>;
    private static knownEntityAddresses;
    private addressInformation;
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class ResourceAddress extends EntityAddress implements IAddress {
    address: string;
    constructor(address: string);
    static decode(bytes: Uint8Array | string, networkId: number): Promise<ResourceAddress>;
    static xrdResourceAddress(networkId: number): Promise<ResourceAddress>;
    static systemTokenResourceAddress(networkId: number): Promise<ResourceAddress>;
    static ecdsaSecp256k1TokenResourceAddress(networkId: number): Promise<ResourceAddress>;
    static eddsaEd25519TokenResourceAddress(networkId: number): Promise<ResourceAddress>;
    static packageTokenResourceAddress(networkId: number): Promise<ResourceAddress>;
    networkId(): Promise<number>;
    networkName(): Promise<string>;
    entityType(): Promise<EntityType>;
    data(): Promise<Uint8Array>;
    hrp(): Promise<string>;
    private static knownEntityAddresses;
    private addressInformation;
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class PackageAddress extends EntityAddress implements IAddress {
    address: string;
    constructor(address: string);
    static decode(bytes: Uint8Array | string, networkId: number): Promise<PackageAddress>;
    static faucetPackageAddress(networkId: number): Promise<PackageAddress>;
    static accountPackageAddress(networkId: number): Promise<PackageAddress>;
    networkId(): Promise<number>;
    networkName(): Promise<string>;
    entityType(): Promise<EntityType>;
    data(): Promise<Uint8Array>;
    hrp(): Promise<string>;
    private static knownEntityAddresses;
    private addressInformation;
    toString(): string;
    toObject(): Record<string, any>;
}
export declare enum EntityType {
    FungibleResource = "FungibleResource",
    NonFungibleResource = "NonFungibleResource",
    Package = "Package",
    NormalComponent = "NormalComponent",
    AccountComponent = "AccountComponent",
    EcdsaSecp256k1VirtualAccountComponent = "EcdsaSecp256k1VirtualAccountComponent",
    EddsaEd25519VirtualAccountComponent = "EddsaEd25519VirtualAccountComponent",
    EpochManager = "EpochManager",
    Clock = "Clock",
    Validator = "Validator",
    IdentityComponent = "IdentityComponent",
    EcdsaSecp256k1VirtualIdentityComponent = "EcdsaSecp256k1VirtualIdentityComponent",
    EddsaEd25519VirtualIdentityComponent = "EddsaEd25519VirtualIdentityComponent",
    AccessControllerComponent = "AccessControllerComponent"
}
